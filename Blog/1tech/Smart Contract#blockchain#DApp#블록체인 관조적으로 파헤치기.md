[블록체인 관조적으로 파헤치기](http://enhanced.kr/postviewer/374) 시리즈의 글입니다.

순수한 블록체인이 과거의 거래내역만을 담은 장부라면, 이더리움은 그 장부에다가 미래의 계약까지 걸어놓은 플랫폼이다. 그 계약을 **Smart Contract**, 또는 **상태변환함수**라 하고, 계약의 바이트코드를 올려놓고 실행할 수 있는 환경을 **EVM**이라 한다.



## EVM (Virtual Machine, 이더리움 가상머신)

Java를 공부해본 사람이라면 JVM에 대해 공부해봤을 것이다. 자바 코드를 짜서 컴파일하면 JVM이 설치된 플랫폼에 맞춰서 바이트코드로 변환해준다. 이 덕분에 자바는 플랫폼 독립적인 언어라는 명성을 갖게 되었다.

EVM도 비슷하다. Smart Contract를 작성하기 위해서는 Solidity라는 언어를 사용한다. 이 언어로 작성된 계약을 컴파일하면 이더리움 바이트코드를 얻을 수 있고, 이 바이트코드를 실행할 수 있는 환경이 곧 EVM이다. 이더리움 네트워크의 각 노드마다 EVM을 가지고 있으며 각자 가지고 있는 계약을 이 환경에서 실행하여 특정 조건이 되었을 때 블록체인을 갱신한다. 

EVM에서는 바이트코드를 사용자가 접근가능한 인터페이스 형태로 제공해주는데 이를 **ABI(Application Binary Interface)**라 한다. 사용자는 콘솔을 통해서, 또는 web3.js와 같은 JSON-RPC 구현체를 통해서 ABI에 접근하여 등록된 계약을 사용할 수 있다.

<img src="https://raw.githubusercontent.com/42deSix/Images/master/evm_principle.png" width="95%"/>



## Accounts (EOA & CA)

이더리움에서 계정(account)이란, 상태(status)정보를 담고 있는 객체다. 계약이 이행되면 이 상태값이 변경되기 때문에 이더리움에서 계약은 '상태변환함수'라고도 불린다. 이더리움의 계정은 기본적으로 다음과 같은 필드(상태값)들을 가진다. 

- nonce

  트랜잭션이 한 번만 실행되었는지 확인하기 위한 값이다. 채굴에서의 nonce와 헷갈릴 수도 있는데, 영어사전에서 nonce를 찾아보면 다음과 같이 나온다.

  > *(말・표현이) 특정 상황에서만 쓰기 위해 만든[임시의]* 

  그러니까 우리가 별 생각없이 선언하는 `tmp`나 `cnt` 같은 이름인 것이다.

- 이더 잔고 (외부소유계정에게만 존재)

  남은 금액에 대한 '값'이다. 블록체인 형태가 아님에 주의하자. 이더리움에서는 블록체인에 잔고 데이터가 아니라 트랜잭션 자체를 저장한다.

- 계약 코드 (계약계정에게만 존재)

  실행 가능한 smart contract 코드의 해시값이 들어있어서 조건이 맞을 때 계약계정이 이 코드를 실행한다. 

- 저장 공간

  저장 공간은 계약계정에서 자체적인 상태값을 나타내기 위해 쓰는, 일종의 전역변수와 유사한 공간이다. 이 공간을 많이 사용하면 수수료가 그만큼 더 지불된다고 한다. 

이더리움의 각 노드는 2개의 계정으로 구성된다.

* **외부 소유 계정(External Owned Accounts, EOA)**

  CA에게 트랜잭션을 전송한다.

* **계약 계정(Contract Accounts, CA)**

  조건이 충족되었을 때 smart contract를 실행하고, 다른 CA에게 메시지를 전송한다.



## Gas

이더리움에 올라가는 계약은 **튜링완전**한 언어로 구현된다(튜링완전이란 개념은 자세히 설명하면 매우 복잡하겠지만, 쉽게 생각해서 그냥 웬만한 명령을 다 수행할 수 있다는 뜻이다). 따라서 무한루프 등으로 인해 이더리움 시스템의 컴퓨팅 자원을 악의적으로, 또는 의도치 않게 소모할 수 있게 된다. 이를 막기 위해 EVM은 어떤 계약을 실행하기 위해 사용자에게 수수료를 선불로 청구하고, 이 수수료를 **gas**라고 한다. 사용자가 지불한 gas는 해당 블록의 채굴자에게 전달된다.



## 계약의 이행 (Transaction & Message)

본래 블록체인시스템에서 트랜잭션은 블록체인에 새로운 데이터를 추가하는 작업이었다. DApp으로 넘어오면서 블록체인에 데이터를 추가할 때 계약이라는 개념이 추가되었기 때문에 트랜잭션의 개념은 좀 더 복잡해진다. DApp에서는 **외부소유계정에서 계약계정에게 보내는 데이터의 묶음**을 트랜잭션이라 한다. 트랜잭션에는 다음 정보들이 포함된다.

- 수신자
- 발신자의 서명
- 보내는 이더의 양
- optional 데이터 필드 (계약이 사용하는 매개변수 정도로 보면 될 것 같다)
- STARTGAS
- GASPRICE

계약은 연쇄적으로도 이행될 수 있다. 이런 경우에는 트랜잭션이 아니라 **메시지**를 통해 이루어진다. 메시지란, **계약계정에서 계약계정에게 보내는 데이터의 묶음**이다. 메시지에는 다음 정보들이 포함된다(GASPRICE가 빠진걸 빼면 트랜잭션과 동일하다).

- 수신자
- (암묵적) 발신자
- 보내는 이더의 양
- optional 데이터 필드
- STARTGAS

예를 들어 노드 A, B, C가 있다고 하자. B의 계약계정은 'A에게서 10이더를 받으면 C에게 10이더를 전송한다'는 계약코드를 갖고 있다. 만약, A의 계약계정이 '지금 B에게 10이더를 보낸다'는 계약을 갖고 있고, A의 외부소유계정이 트랜잭션을 만들어 A의 계약계정에 보낸다면, A의 계약계정은 A의 외부소유계정에서 10이더를 빼서 B의 외부소유계정에 더하고, A의 계약계정은 또 B의 계약계정에게 메시지를 전달해 계약을 연쇄적으로 실행시킬 것이다. 그럼 B의 외부소유계정에서 다시 10이더가 빠지고, C의 외부소유계정에 10이더가 더해질 것이다.

그런데 계약의 이행은 무료로 이루어지지 않는다. 계약을 이행하기 위해서는 수수료로 gas가 소모된다. 이 수수료의 값을 트랜잭션의 GASPRICE로 정해두고, 매 계약 이행시 GASPRICE만큼을 A의 외부소유계정에서 제한다. GASPRICE의 값이 클 수록 해당 트랜잭션의 우선순위와 속도가 상승한다. 

그런데 위의 상황처럼 계약이 연쇄적으로 일어나는 경우, B의 계약을 위한 gas도 트랜잭션을 발행한 A에서 내야 한다. A 입장에서 연쇄계약이 얼마나 이루어질지 알 수 없기 때문에 트랜잭션에 최대계산단계 수인 STARTGAS값을 설정하여 gaslimit = STARTGAS * GASPRICE를 정한다. 수수료가 gaslimit을 초과하는 순간, 지금까지 이행된 모든 계약은 롤백되고, A가 낸 수수료는 모두 환급되지 않고 블록채굴자에게 전달된다. 이런 불합리해보이는 시스템을 쓰는 이유는 악의적으로 시스템의 컴퓨팅자원을 모두 소모하는 것을 막기 위함이다.



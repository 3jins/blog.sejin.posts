[블록체인 관조적으로 파헤치기](http://enhanced.kr/postviewer/374) 시리즈의 글입니다.

블록체인이라 하면 흔히들 암호화폐부터 떠올린다. 하지만 그 기술 쪽을 파헤쳐보면 P2P 네트워크 구조의 일종으로 보는 게 더 적절하다. 여기에 Smart Contract라는 프로그래밍 개념을 입히면 아예 웹앱이 된다. 딥러닝을 적용하기에 바둑을 두는 알파고가 가장 적절했듯이 암호화폐는 블록체인을 적용하기에 가장 적절한 프로젝트였을 뿐이다.



## Structure

기본적으로 블록체인 기반의 시스템이라 하면 **네트워크 시스템을 전제로** 한다. 각자의 전공을 막론하고 여러분이 흔히 들어봤을 암호화폐를 예로 들어 아주 얕게만 생각해 보더라도 송금을 위해서는 지갑들이 서로 연결될 필요가 있지 않은가. 헷갈리지 않기 위해 어찌 보면 당연한 이 개념을 잘 잡고 들어가도록 하자.

### node & client

#### node

블록체인 시스템에 참여하는 각각의 사용자. 각각의 노드는 지금까지의 transaction 내역을 모두 담고 있는 장부를 하나씩 들고 있다. 이 장부가 바로 블록체인이다. client가 **transaction**을 발생시킬 때마다 각 노드는 블록체인을 동기화한다. 

트랜잭션이 발생할 때마다 매번 모든 노드가 블록체인을 동기화하려면 엄청난 비용이 든다. 그래서 노드의 종류는 보통 하나가 아니고 블록체인의 종류에 따라 여러 가지가 있을 수 있다. 예를 들어, Full Node는 지금까지의 모든 트랜잭션 정보를 담고 있어 위조 여부 등을 검증할 수 있는 노드고, Light-weight Node는 요약된 정보만을 가지고 있다. 현실적으로 기기마다 모든 체인을 저장하고 있을 수는 없기 때문에(현재 비트코인의 경우 체인의 전체 크기가 100GB가 넘는다) 검증 작업은 Full Node에게 위탁하는 방식을 취한다. 

#### client

기존의 웹앱에서는 중앙에 데이터베이스를 관리하는 backend가 하나 있고, 모든 사용자가 클라이언트를 통해 백엔드의 데이터에 접근했었다. 블록체인의 경우 이 시스템이 각각의 노드에 하나씩 들어있다고 생각하면 된다. client는 **query**를 통해 블록체인의 정보를 조회하거나, 블록에 새로운 데이터를 추가하는 행위인 **transaction**을 발생시킬 수 있다.

| <img src="https://raw.githubusercontent.com/42deSix/Images/master/blockchain_node_client.png" width="90%"/> |
| :----------------------------------------------------------: |
| 네트워크의 각 노드마다 블록체인이 들어있어 사용자가 이를 이용해 트랜잭션을 생성할 수 있다. |

### Blockchain

각 노드가 가지고 있는 **트랜잭션 리스트**로 DApp에서 데이터베이스의 역할을 한다. 

블록들은 링크드리스트 방식으로 연결되어 있으며, 각 블록에는 블록의 해시값 등 채굴에 필요한 정보들이 담긴 헤더와 함께 일정량의 트랜잭션이 발생한 시간 순서대로 저장된다. 

<img src="https://raw.githubusercontent.com/42deSix/Images/master/blockchain_structure.png" width="90%"/>

블록은 끊임없이 전세계에서 보상을 노리는 누군가에 의해 채굴되며, 그 동안 발생한 트랜잭션은 이미 생성된 블록 내에 차곡차곡 쌓이게 된다. 



## Behaviors

블록체인은 Update나 Delete가 불가능한 구조로 오직 읽기(Read)와 추가(Create)만 가능하다. 이 때문에 블록체인 시스템에서는 한 번 일어났던 트랜잭션을 없던 일로 되돌리는 게 불가능하다. 그래서 블록체인을 **영구불변의 탈중앙화 원장**이라고 부른다. 일례로 블록체인 기반의 [스팀잇](https://steemit.com) 블로그 서비스의 경우 글을 작성 후 일주일이 지나면 수정/삭제가 불가능해진다고 한다.

### Query

블록체인에서 데이터를 쿼리하는 작업이다. 기존 DBMS의 CRUD 중 R(Read)에 해당한다.

### Transaction

블록체인에 새로운 데이터 내지는 거래기록을 추가하는 작업이다. 기존 DBMS의 CRUD 중 C(Create)에 해당한다.

다음의 순서로 일어난다.

1. 트랜잭션 생성

   한 클라이언트 A에서 트랜잭션이 생성된다.

2. 트랜잭션 전파

   2-1. 전파

   ​	2-1-1. A의 비밀키로 트랜잭션을 서명한다.

   ​	2-1-2. 서명된 트랜잭션을 A의 노드로 전송한다. 

   2-2. 검증

   ​	2-2-1. Full Node에게 트랜잭션을 보낸다.

   ​	2-2-2. Full Node는 트랜잭션이 유효한지 검증한다. 이 과정에서 **PoW** 등의 알고리즘을 사용한다.

   ​	2-2-3. Full Node는 트랜잭션이 모이면 블록을 갱신하고 이를 전파한다.

저 2-2. 검증 단계가 블록체인의 유일한 장점을 지키는 핵심 수단이라 봐도 과언이 아니다. 웹앱은 중앙 서버 한 대의 데이터만 수정하면 되므로 데이터를 추가하는 게 빠르지만, 블록체인은 모든 노드가 장부를 동기화하는 작업이 수반되어야 하기 때문에 필연적으로 속도상의 손해가 있을 수밖에 없다. 뿐만 아니라, [나중 글](http://enhanced.kr/postviewer/43)에서 다루겠지만, PoW를 따르는 블록체인 시스템에서는 새로운 블록을 생성하는 데에 상당히 긴 시간이 소요된다. 이 손해를 감수하고 블록체인이 가져가려는 이점은 **무결성**이다. 

Update와 Delete를 없앴다고 하지만 비정상적인 방법으로 장부를 조작할 수 있다면 말짱 도루묵이다. 이를 막기 위한 방법으로 블록체인이 사용하는 게 검증 단계다. 다음 글에서부터 **검증 및 합의 알고리즘**에 대해 다뤄보도록 하자.


알고리즘 공부를 하다 보면 재귀로 짜면 쉬운 문제인데도 자꾸 DP부터 쓰려고 발악하다가 시간을 낭비하기도 하고, 머리에 구겨넣은 지식이 많아지면서 내가 뭘 알고 뭘 모르는지 헷갈리기도 한다. 쓸 수 있는 전략의 갯수가 많아지면서 문제풀이에 있어서 불필요한 오버헤드가 늘어나는 것이다. 내 기억에 수능도 그러다가 망했던 것 같다. **문제를 풀 수 있는 것과 문제를 항상 풀 수 있는 것은 다르다**는 것을 잊지 말아야 할 것이다.

무릇 빅오 노테이션을 배운 자라면 워스트케이스에 항상 대비해야 하는 법. 나중에 코딩테스트에 떨어지고 나서 부족한 재능에 탄식해봐야 돌아오는 것은 없다. 지존의 경지에 도달한 대마법사라 하더라도 악마와 싸울 때는 맨 손으로 마법을 쓰지 않고 스태프를 쓴다. 우리 또한 아무 준비 없이 코딩테스트에 임했다가는 쳐발릴 확률이 높아질 뿐이므로, 머리 탓만 하지 말고 미리미리 도구를 준비해야 할 것이다.

이번 포스트는 알고리즘 문제를 만났을 때 주어진 조건에 따라 어떤 알고리즘을 써야 하는지에 대해 정리하는 글이다. 코드 짜고 디버깅하기도 시간이 빡빡할 실전에서는 불필요한 고민으로 낭비해도 되는 시간과 체력 따위는 없다. 아직 나의 배움이 부족하므로 이 글은 지속적으로 업데이트 되겠다. 





## 1. n개 입력에 대한 Loop 문제들

C++ 기준으로 루프 100만번이 1초라고 보면 된다. 보통 시간제한으로 1~3초 정도를 주니까 저 100만번이 필요한 시간복잡도를 가늠하는 기준이 된다.



### $O(n^2)$

입력이 1000단위 이하면 써도 된다. (1,000 * 1,000 = 1,000,000)

#### 1-1. 단일 루프, 이중 루프 

감 못 잡고 멍하니 있는것보다 이걸로 슈도코드라도 짜보는 게 낫다. 그 과정에서 종종 생각이 정리되기도 한다.

#### 1-2. 재귀

어려워 보이면 일단 재귀로 풀 수 있는지를 확인하는 게 우선이다. (http://enhanced.kr/postviewer/295)

형선왈: 재귀로 배열이나 벡터를 넘기면 공간복잡도가 증식한다. 최대한 전역으로 돌려라.



### $O(n \log n)$

소팅 외에는 보기 어렵다. 입력값이 애매하게 10만 정도로 주어진다면 여기다. ($100, 000 * \log_2{131,072} = 1,700,000$)

#### 1-3. sort (in `<algorithm>` STL)

C++에서 기본으로 제공하는 sort가 $O(n \log n)$의 시간이 걸린다. 퀵소트 같은걸 직접 짜도 되지만 굳이..? (그리고 사실 웬만해선 주니어 개발자가 짠 소트보단 STL의 소트가 더 빠르다.)



### $O(n)$

입력의 크기가 100만 단위일 때까지 쓸 수 있다. 보통은 $O(n)$으로 짜서 시간초과가 나지는 않지만 가끔은 커버되지 않기도 한다.

#### 1-4. HashMap

시간복잡도의 한계를 돌파하라는 문제, 특히 루프 두번 돌아야 하는 문제를 $O(n)$에 끝내라고 하면 해쉬맵이다. (http://enhanced.kr/postviewer/248)

#### 1-5. DP

존나 연습하면 된다.



### $O(\sqrt n)$

$O(\sqrt n)$이라는 표기가 낯설 것이다. 왜냐하면 얘를 별도로 취급하는 일은 거의 없기 때문이다. 엄밀히 말해서 $O(n^{{1} \over {2}})$이므로 $O(n)$보다 빠르지만 그냥 $O(n)$으로 간주해도 무방하다.

주로 소수/약수 관련 문제에서 `int limit = ceil(sqrt(n)); for(int i = 0; i < limit; i++)`과 같은 식으로 쓰인다.



### $O(\log n)$

$O(n)$으로 돌렸는데 안되면 90% 이상 여기다. 

#### 1-6. 이진탐색, 균형이진트리

1학년 때 마시면서 배우던 바로 그 바이너리 서치다. 업다운 게임이 다른 게임들에 비해 빨리 끝나는 이유는 시간복잡도가 $O(\log n)$ 밖에 되지 않기 때문이다. ~~전갈게임은 시간복잡도가 무려 $O(1)$이다.~~



### $O(1)$

여기부턴 사실상 꼼수의 영역이다. 알면 푸는 거고 모르면 못 푸는 거다. 문제해결능력과는 별로 상관이 없고 짬에서 나오는 바이브로 풀어야 한다.

#### 1-7. 니가 공부를 못하는 건 벼락치기만 하기 때문이다.

시험 전범위를 하루만에 커버하려면 매일 수업이 끝났을 때마다 복습을 해두면 된다.

마찬가지로 스택의 크기를 $O(1)$ 시간에 구하려면 `push`할 때마다 그 크기를 1씩 더해두면 된다.

스택은 DB가 될 수도 있고 트래픽 통계치가 될 수도 있다. 뭐든 쌓이는 거라면 쌓을 때마다 그 때 그 때 연산을 처리해주자. 

#### 1-8. Hack by Math

1~n의 합을 구하는 방법은 두 가지다.

* $O(n)$: `for(int i=0; i<n; i++) sum += i;`
* $O(1)$: `sum = n / 2 * (n + 1);`

등비수열도 합의 공식이 있고, 2차 방정식의 해를 구하는 것도 공식이 있고, 중고등학교 수학시간에 배운 공식들 중에 유용한 게 생각보다 많다. 무조건 루프 돌려서 답 찾지 말고 공식을 활용하자.





## 2. 길 찾기

카카오 코드페스티벌에서 좋아하는 길찾기. 카카오와 길찾기문제의 관계는 존박과 냉면의 관계와 같다. 어쩐지 다음지도가 잘 만들어져있더라. ~~하지만 난 네이버지도를 쓴다.~~

간선 수를 `E`, 노드 수를 `V`라 하겠다.



### $O(VE)$

#### 2-1. BFS

입사 코딩테스트 레벨에선 얘밖에 본 적이 없다. 

BFS는 모든 노드를 다 탐색한다. 하지만, 모든 간선을 탐색하는 것은 아니다. 따라서 **최단거리**를 구하거나 **영역의 넓이**를 구할 때는 좋지만, 경로의 수를 구할 때는 적절한 방법이 아니다. 경로의 수를 셀 때는 [보행자 천국](http://tech.kakao.com/2017/08/11/code-festival-round-1/#%EB%B3%B4%ED%96%89%EC%9E%90-%EC%B2%9C%EA%B5%AD) 문제처럼 2차 DP(파스칼의 삼각형)를 활용해야 한다.

#### 2-2. DFS

추측이지만 DFS로 풀 수 있는 건 모두 BFS로도 풀 수 있는 것 같다. DFS는 연습해본 적이 없다.



### $O(n \log n)$

#### 2-3. Dijkstra

그냥 이름이 간지나서 유명한 거 같다. ~~이름 중간에 연속한 세 알파벳(i, j, k)이 있고 그 다음에도 연속한 세 알파벳(r, s, t)이 순서만 한 칸씩 밀려서 나온다.~~  교과서에서 배운대로 짜면 $O(VE)$ 나온다. 여기서 뭘 어떻게 하면 $O(n \log n)$의 시간복잡도로 풀린다는데 잘 모르겠다. 



### $O(?)$

#### 2-4. Kruskal

Disjoint Set과 밀접한 관련이 있다. 코드 짜본 적이 없어서 잘 모른다.

#### 2-5. A*

무슨 중2병 걸린 것 마냥 에이스타라고 읽는다. 들어만 봤다. 





## 3. 그 외

이 쪽으로 넘어왔으면 풀기 전까지는 문제 난이도를 예측할 수 없다. 마치 드래곤볼Z에서 전투력 측정이 안되는 손오반과 싸우게 된 베지터의 상황과 같다. 괜히 객기 부리면서 시간 낭비하지 말고 마지막에 풀자.

#### 3-1. Counting

잘 모르겠으면 기본으로 돌아가라. 그냥 직접 세는 게 가장 빠를 수 있다.

괄호조합문제 (http://enhanced.kr/postviewer/227)

#### 3-2. Disjoint Set

아직 경험이 부족해서 잘 모르겠다. 나중에 BFS 마스터할 때처럼 백준 같은데 들어가서 몰아서 풀어봐야지.

#### 3-3. 문자열 파싱

추측이지만 정규표현식 마스터하면 커버 가능할 것 같다. 그냥 풀려고 하면 예외상황이 겁나 많아서 어렵다.
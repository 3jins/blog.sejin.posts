BFS(Breadth First Search)는 DFS와 같이 길 찾기 알고리즘의 가장 기초로 등장하는 알고리즘이다. 학교에서 알고리즘을 배우면 그래프가 뭔지 배운 뒤에 바로 BFS와 DFS를 배우고 다익스트라, 크루스칼, 벨만포드 등의 알고리즘을 하나씩 배우게 된다.

다른 알고리즘에 비해 이름에서 임팩트가 부족하고 개념 자체만 놓고 봤을 때는 아주 간단하기 때문에 잘 모르지만, 이 알고리즘을 직접 문제풀이에 적용하려고 들면 생각보다 쉽지가 않다(그냥 내가 코딩을 못하는 것일지도 모른다). 하지만 문제마다 푸는 법이 비슷하기 때문에 그냥 정형화해서 외워두면 좀 수월하게 풀 수 있다. 



## BFS의 필수요소들

심하게 어려운 몇몇 문제들을 제외하면 푸는 요령이 동일한 것 같다. 주어진 조건에 따라 적당히 임기응변의 코드를 넣어야 하겠지만 기본적으로 다음의 요소들을 반드시 포함해야 한다.



### Node

노드에는 다음 두 가지 요소가 포함돼있어야 한다.

* 좌표
* 연산값

'연산값'에는 출발점으로부터의 거리나 지나온 노드들과 같은, 문제에서 출력하라고 요구하는 답이 저장된다. 노드를 한 발짝 옮길 때마다 후술할 `findNeighbors`에서 거리 등의 값을 갱신해둔다.



### Queue

**DFS는 Stack, BFS는 Queue**라는 공식이 있다. BFS의 Queue는 지역변수로 만들어서 매개변수로 넘기느라 낑낑대지 말고 그냥 전역변수로 선언하는 게 정신건강에 좋다. BFS의 Queue는 다음의 규칙대로 채워지고 비워진다.

- 현재 노드에 인접한 노드들을 큐에 집어넣는다.
- 현재 노드를 방문하고 나면 현재 노드를 큐에서 뺀다. 
- 큐가 완전히 비었으면 더 이상 갈 곳이 없음을 의미한다.

큐에 인접노드를 집어넣을 때는 이 인접노드를 이미 방문한 적이 있는지 **isVisited** 배열을 통해 확인해야 한다.



### adjacent matrix / list (map, isVisited)

경로탐색 문제는 문제의 상황을 그래프로 모델링해서 푸는 경우가 많다. 모델링 작업을 위해 쓰는 방법이 둘로 나뉘는데, 하나는 인접 행렬이고, 다른 하나는 인접 리스트다.

인접 행렬은 별 거 아니고 그냥 2차원 배열로 문제 상황을 표현한 것이다. 

인접 리스트는 각 노드마다 인접한 노드들을 링크드리스트로 저장한거다. 인접행렬에서 일부 시간복잡도를 포기하고 공간복잡도를 최적화한 결과라고 생각하면 되겠다.

문제에서 주어진 그래프 정보를 담고 있는 **map** 배열이 있어야 함은 물론이고, map 배열과 모양이 똑같은 **isVisited** 배열이 필요하다. 방문했으면 1, 방문하지 않았으면 0을 집어넣거나 하는 식인데, 보통 문제 조건에 따라 이 isVisited 배열에 데이터를 저장하는 형태가 많이 달라지게 된다.



### vector\<Node\> findNeighbors(Node)

인접한 노드들을 구한다. 이 때 다음과 같은 처리를 거쳐야 한다.

* 해당 좌표가 유효한(map의 범위 안에 있는) 좌표인지를 살핀다.
* 현재 Node의 연산값을 가지고 이웃좌표의 연산값을 갱신한다.



## BFS 적용하기

BFS를 쓰기 위해 뭐가 필요한지는 알았으니 이젠 그 부품들을 조립해서 알고리즘을 완성해보자.



### 1. Initialization

* map을 복제해서 isVisited 배열을 만든다.
* 시작점 Node에 값을 채운다.
* 큐에 시작점 Node를 push한다.



### 2. Loop ( while(!bfsQ.empty()) )

* 현재 좌표 갱신
  * curCoord = bfsQ.pop()
  * 목적지에 도착했는지 확인하고, 만약 도착했다면 이게 최단거리이므로 curCoord의 '연산값'을 출력하고 리턴한다.
  * isVisited 배열에 현재 좌표를 방문했다고 마킹한다.
* 이웃 좌표 찾기
  * getNeighbors 함수로 이웃한 노드들을 찾는다.
  * 각 이웃한 노드들에 대해 방문한 적이 없는 노드라면, 큐에 push한다.



### 3. 후처리

* 큐가 다 빌 때까지 목적지에 도착하지 못했다면 루프를 빠져나왔을 것이다. 그럼 목적지에 도달할 수 없는 상황이므로 이에 대한 처리를 해준다.

